<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>节奏练习助手</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
  
  <!-- 配置Tailwind自定义主题 -->
  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            primary: '#3B82F6',
            secondary: '#1E40AF',
            accent: '#F59E0B',
            danger: '#EF4444',
            success: '#10B981',
            dark: '#1E293B',
            light: '#F8FAFC'
          },
          fontFamily: {
            sans: ['Inter', 'system-ui', 'sans-serif'],
          },
        },
      }
    }
  </script>
  
  <style type="text/tailwindcss">
    @layer utilities {
      .content-auto {
        content-visibility: auto;
      }
      .shadow-depth {
        box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.1), 0 8px 10px -6px rgba(0, 0, 0, 0.1);
      }
      .transition-all-300 {
        transition: all 300ms ease-in-out;
      }
      .timeline-marker {
        position: absolute;
        width: 4px;
        transform: translateX(-50%);
        z-index: 10;
      }
      .timeline-label {
        position: absolute;
        transform: translateX(-50%);
        white-space: nowrap;
        z-index: 20;
      }
      .countdown-overlay {
        position: fixed;
        inset: 0;
        background: rgba(0,0,0,0.7);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 100;
        font-size: 10rem;
        font-weight: bold;
        color: white;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.3s ease;
      }
      .countdown-visible {
        opacity: 1;
        pointer-events: auto;
      }
      .history-row-latest {
        border-left: 3px solid #F59E0B;
      }
      .modal-backdrop {
        position: fixed;
        inset: 0;
        background: rgba(0,0,0,0.7);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 200;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.3s ease;
      }
      .modal-visible {
        opacity: 1;
        pointer-events: auto;
      }
      .rule-group {
        border: 1px solid #374151;
        border-radius: 0.5rem;
        transition: all 0.2s;
      }
      .rule-group:hover {
        border-color: #4F46E5;
        background-color: rgba(79, 70, 229, 0.05);
      }
      .rule-handle {
        cursor: move;
      }
    }
    
    @keyframes beat {
      0% { transform: scale(1); }
      50% { transform: scale(1.2); }
      100% { transform: scale(1); }
    }
    
    .beat-animation {
      animation: beat 0.3s ease-in-out;
    }
    
    @keyframes pulse {
      0% { opacity: 0.6; }
      50% { opacity: 1; }
      100% { opacity: 0.6; }
    }
    
    .pulse-animation {
      animation: pulse 1s infinite;
    }
  </style>
</head>
<body class="bg-gradient-to-br from-dark to-slate-800 text-light min-h-screen flex flex-col">
  <!-- 用户选择对话框 -->
  <div id="userSelectionModal" class="modal-backdrop">
    <div class="bg-dark rounded-xl p-6 max-w-md w-full mx-4 border border-secondary/30 shadow-depth">
      <div class="text-center mb-4">
        <h3 class="text-xl font-bold text-primary">选择练习者</h3>
      </div>
      <div class="space-y-3 mb-6" id="userList">
        <!-- 用户选项将通过JS动态生成 -->
      </div>
      <div class="mb-4">
        <label class="block text-sm text-slate-300 mb-2">自定义名称</label>
        <input 
          type="text" 
          id="customUserName" 
          placeholder="输入自定义名称" 
          class="w-full bg-slate-800 border border-slate-700 rounded-lg px-3 py-2 focus:outline-none focus:ring-2 focus:ring-primary"
          disabled
        >
      </div>
      <div class="flex justify-end">
        <button id="confirmUserBtn" class="bg-primary hover:bg-primary/80 text-white font-medium py-2 px-6 rounded-lg transition-all-300">
          确定
        </button>
      </div>
    </div>
  </div>

  <!-- 设置菜单对话框 -->
  <div id="settingsModal" class="modal-backdrop">
    <div class="bg-dark rounded-xl p-6 max-w-4xl w-full mx-4 border border-secondary/30 shadow-depth max-h-[90vh] overflow-y-auto">
      <div class="text-center mb-6">
        <h3 class="text-xl font-bold text-primary">设置</h3>
      </div>
      
      <div class="space-y-8">
        <!-- 目标分数设置 -->
        <div>
          <h4 class="text-lg font-semibold mb-4 text-secondary">胜利条件</h4>
          <div>
            <label for="targetScoreInput" class="block text-sm text-slate-300 mb-2">
              目标分数（达到此分数获胜）
            </label>
            <div class="space-y-3">
              <div class="flex items-center gap-4">
                <input 
                  type="number" 
                  id="targetScoreInput" 
                  min="10" 
                  max="5000" 
                  value="100" 
                  class="flex-1 bg-slate-800 border border-slate-700 rounded-lg px-3 py-2 focus:outline-none focus:ring-2 focus:ring-primary"
                >
                <span class="text-slate-300">分</span>
              </div>
              <input 
                type="range" 
                id="targetScoreSlider" 
                min="10" 
                max="5000" 
                value="100" 
                class="w-full h-2 bg-slate-700 rounded-lg appearance-none cursor-pointer accent-primary"
              >
            </div>
          </div>
        </div>
        
        <!-- MIDI延时调整 -->
        <div>
          <h4 class="text-lg font-semibold mb-4 text-secondary">MIDI设置</h4>
          <div>
            <label for="midiDelayInput" class="block text-sm text-slate-300 mb-2">
              MIDI输入延时调整 (ms)
            </label>
            <div class="space-y-3">
              <div class="flex items-center gap-4">
                <input 
                  type="number" 
                  id="midiDelayInput" 
                  min="-100" 
                  max="100" 
                  value="0" 
                  class="flex-1 bg-slate-800 border border-slate-700 rounded-lg px-3 py-2 focus:outline-none focus:ring-2 focus:ring-primary"
                >
                <span class="text-slate-300">ms</span>
              </div>
              <input 
                type="range" 
                id="midiDelaySlider" 
                min="-100" 
                max="100" 
                value="0" 
                class="w-full h-2 bg-slate-700 rounded-lg appearance-none cursor-pointer accent-primary"
              >
              <p class="text-xs text-slate-400">
                调整MIDI输入的延时补偿，正值表示提前触发，负值表示延迟触发
              </p>
            </div>
          </div>
        </div>
        
        <!-- 分数规则设置 -->
        <div>
          <div class="flex justify-between items-center mb-4">
            <h4 class="text-lg font-semibold text-secondary">分数规则设置</h4>
            <div class="text-xs text-slate-400">
              提示：相邻范围会自动匹配，最大范围以上将使用该范围规则
            </div>
          </div>
          
          <div id="scoreRulesContainer" class="space-y-4">
            <!-- 分数规则项将通过JS动态生成 -->
          </div>
        </div>
      </div>
      
      <div class="flex justify-end gap-3 mt-8">
        <button id="resetRulesBtn" class="bg-slate-700 hover:bg-slate-600 text-white font-medium py-2 px-4 rounded-lg transition-all-300 text-sm">
          恢复默认规则
        </button>
        <button id="cancelSettingsBtn" class="bg-slate-700 hover:bg-slate-600 text-white font-medium py-2 px-6 rounded-lg transition-all-300">
          取消
        </button>
        <button id="saveSettingsBtn" class="bg-primary hover:bg-primary/80 text-white font-medium py-2 px-6 rounded-lg transition-all-300">
          保存设置
        </button>
      </div>
    </div>
  </div>

  <!-- 倒计时覆盖层 -->
  <div id="countdownOverlay" class="countdown-overlay"></div>

  <!-- 顶部导航 -->
  <header class="bg-dark/80 backdrop-blur-md border-b border-slate-700 py-4 px-6 sticky top-0 z-50">
    <div class="container mx-auto flex flex-wrap justify-between items-center gap-4">
      <div class="flex items-center gap-2">
        <i class="fa fa-music text-primary text-2xl"></i>
        <h1 class="text-xl md:text-2xl font-bold">节奏练习助手</h1>
      </div>
      <div class="flex items-center gap-4">
        <!-- MIDI连接按钮 -->
        <button id="connectMidiBtn" class="text-primary hover:text-primary/80 text-sm font-medium transition-all-300 flex items-center gap-1">
          <i class="fa fa-plug"></i>
          <span id="midiBtnText">连接MIDI设备</span>
        </button>
        
        <!-- 当前用户显示 -->
        <div id="currentUserDisplay" class="hidden items-center gap-2 px-3 py-1 bg-primary/20 rounded-full text-sm">
          <i class="fa fa-user text-primary"></i>
          <span id="userNameText"></span>
        </div>
        
        <!-- 目标分数显示 -->
        <div class="hidden items-center gap-2 px-3 py-1 bg-accent/20 rounded-full text-sm" id="targetScoreDisplay">
          <i class="fa fa-bullseye text-accent"></i>
          <span>目标: <span id="targetScoreValue">100</span>分</span>
        </div>
        
        <!-- 顶部开始/停止按钮 -->
        <button id="startStopBtn" class="bg-primary hover:bg-primary/80 text-white font-medium py-2 px-6 rounded-lg transition-all-300 flex items-center gap-2">
          <i class="fa fa-play"></i>
          <span>开始练习</span>
        </button>
        <button id="helpBtn" class="p-2 hover:bg-slate-700 rounded-full transition-all-300">
          <i class="fa fa-question-circle text-slate-300"></i>
        </button>
        <button id="settingsBtn" class="p-2 hover:bg-slate-700 rounded-full transition-all-300">
          <i class="fa fa-cog text-slate-300"></i>
        </button>
      </div>
    </div>
  </header>

  <!-- 主要内容 -->
  <main class="flex-grow container mx-auto px-4 py-8">
    <!-- 核心状态显示 - 包含当前得分 -->
    <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-6 max-w-6xl mx-auto mb-8">
      <!-- 当前总分 -->
      <div class="bg-dark/60 backdrop-blur-sm rounded-xl p-4 shadow-depth border border-slate-700 text-center">
        <h2 class="text-slate-300 mb-2">当前总分</h2>
        <div id="currentScoreDisplay" class="text-4xl md:text-5xl font-bold text-accent">0</div>
      </div>
      
      <!-- 最佳单次得分 -->
      <div class="bg-dark/60 backdrop-blur-sm rounded-xl p-4 shadow-depth border border-slate-700 text-center">
        <h2 class="text-slate-300 mb-2">最佳单次得分</h2>
        <div id="bestScoreDisplay" class="text-4xl md:text-5xl font-bold text-secondary">0</div>
      </div>
      
      <!-- 最差单次得分 -->
      <div class="bg-dark/60 backdrop-blur-sm rounded-xl p-4 shadow-depth border border-slate-700 text-center">
        <h2 class="text-slate-300 mb-2">最差单次得分</h2>
        <div id="worstScoreDisplay" class="text-4xl md:text-5xl font-bold text-danger">0</div>
      </div>
      
      <!-- 最近差值 -->
      <div class="bg-dark/60 backdrop-blur-sm rounded-xl p-4 shadow-depth border border-slate-700 text-center">
        <h2 class="text-slate-300 mb-2">最近差值(ms)</h2>
        <div id="latestDifferenceDisplay" class="text-4xl md:text-5xl font-bold text-success">0</div>
      </div>
    </div>
    
    <!-- 当前计分规则说明 -->
    <div class="max-w-6xl mx-auto mb-8 bg-dark/60 backdrop-blur-sm rounded-xl p-4 shadow-depth border border-slate-700">
      <h3 class="text-lg font-semibold mb-3 flex items-center">
        <i class="fa fa-info-circle text-accent mr-2"></i>
        当前计分规则
      </h3>
      <div id="currentRulesDisplay" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-3 text-sm">
        <!-- 规则将通过JS动态生成 -->
      </div>
      <p class="mt-3 text-sm text-slate-400">达到 <span id="ruleTargetScore">100</span> 分即可获胜！</p>
    </div>
    
    <!-- 节拍视觉指示器与鼠标点击区 -->
    <div class="flex justify-center mb-8">
      <div id="beatIndicator" class="w-32 h-32 md:w-48 md:h-48 rounded-full bg-primary/20 border-4 border-primary/40 flex items-center justify-center cursor-pointer hover:bg-primary/30 transition-all-300">
        <div class="w-24 h-24 md:w-36 md:h-36 rounded-full bg-primary/30 flex items-center justify-center">
          <span id="beatCounter" class="text-2xl md:text-4xl font-bold">0</span>
        </div>
      </div>
    </div>
    <p class="text-center text-slate-400 mb-8">点击圆形区域或使用MIDI键盘按键进行练习</p>
    
    <!-- 时间轴显示区域 -->
    <div class="max-w-6xl mx-auto mb-8">
      <div class="flex flex-wrap justify-between items-center mb-4 gap-4">
        <h3 class="text-lg font-semibold flex items-center">
          <i class="fa fa-clock-o text-accent mr-2"></i>
          节奏时间轴
        </h3>
        <div class="flex gap-4">
          <div class="flex items-center">
            <span class="text-sm text-slate-300 mr-2">显示单位:</span>
            <button id="msUnitBtn" class="bg-primary/20 hover:bg-primary/30 text-primary px-3 py-1 rounded text-sm transition-all-300">毫秒</button>
            <button id="beatUnitBtn" class="bg-slate-700/50 hover:bg-slate-700 px-3 py-1 rounded text-sm transition-all-300">拍</button>
          </div>
          <div class="flex items-center">
            <span class="text-sm text-slate-300 mr-2">时间轴缩放:</span>
            <button id="zoomOutBtn" class="bg-slate-700/50 hover:bg-slate-700 p-1 rounded text-sm transition-all-300">
              <i class="fa fa-search-minus"></i>
            </button>
            <span id="zoomLevelText" class="mx-2 text-sm">50%</span>
            <button id="zoomInBtn" class="bg-slate-700/50 hover:bg-slate-700 p-1 rounded text-sm transition-all-300">
              <i class="fa fa-search-plus"></i>
            </button>
          </div>
        </div>
      </div>
      
      <div class="bg-dark/60 backdrop-blur-sm rounded-xl p-4 shadow-depth border border-slate-700 relative">
        <!-- 时间轴容器 -->
        <div id="timelineContainer" class="h-40 overflow-x-auto relative">
          <div id="timeline" class="absolute top-0 left-0 h-full w-[5000px]">
            <!-- 时间轴线 -->
            <div class="absolute top-1/2 w-full h-0.5 bg-slate-700 transform -translate-y-1/2"></div>
            
            <!-- 节拍线标记区 -->
            <div id="beatMarkers" class="absolute top-0 left-0 w-full h-full"></div>
            
            <!-- 按键标记区 -->
            <div id="keyMarkers" class="absolute top-0 left-0 w-full h-full"></div>
            
            <!-- 差距显示区 -->
            <div id="differenceLabels" class="absolute top-0 left-0 w-full h-full"></div>
            
            <!-- 当前时间线 -->
            <div id="currentTimeIndicator" class="absolute top-0 bottom-0 w-1 bg-accent/50 pulse-animation hidden"></div>
          </div>
        </div>
        
        <!-- 时间轴图例 -->
        <div class="flex flex-wrap justify-center gap-6 mt-4 text-sm">
          <div class="flex items-center">
            <div class="w-4 h-10 bg-primary mr-2"></div>
            <span class="text-slate-300">正式节拍</span>
          </div>
          <div class="flex items-center">
            <div class="w-4 h-10 bg-accent/60 mr-2"></div>
            <span class="text-slate-300">预备节拍</span>
          </div>
          <div class="flex items-center">
            <div class="w-4 h-10 bg-secondary mr-2"></div>
            <span class="text-slate-300">按键标记</span>
          </div>
          <div class="flex items-center">
            <div class="w-4 h-4 bg-accent rounded-full mr-2 pulse-animation"></div>
            <span class="text-slate-300">当前时间</span>
          </div>
        </div>
      </div>
    </div>
    
    <!-- 分数与差值记录表格 -->
    <div class="max-w-6xl mx-auto mb-8">
      <div class="flex justify-between items-center mb-4">
        <h3 class="text-lg font-semibold flex items-center">
          <i class="fa fa-history text-accent mr-2"></i>
          分数与差值记录
        </h3>
        <button id="clearHistoryBtn" class="text-sm text-slate-400 hover:text-slate-200 transition-all-300">
          <i class="fa fa-trash mr-1"></i> 清空记录
        </button>
      </div>
      
      <div class="bg-dark/60 backdrop-blur-sm rounded-xl p-4 shadow-depth border border-slate-700 overflow-x-auto">
        <table class="min-w-full text-sm">
          <thead>
            <tr class="border-b border-slate-700">
              <th class="py-2 px-4 text-left">序号</th>
              <th class="py-2 px-4 text-left">所属节拍</th>
              <th class="py-2 px-4 text-left">按键时间</th>
              <th class="py-2 px-4 text-left">时间差(ms)</th>
              <th class="py-2 px-4 text-left">本次得分</th>
              <th class="py-2 px-4 text-left">累计总分</th>
            </tr>
          </thead>
          <tbody id="historyTableBody">
            <tr>
              <td colspan="6" class="py-4 text-center text-slate-400">暂无记录</td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>
    
    <!-- 控制面板 -->
    <div class="grid grid-cols-1 md:grid-cols-2 gap-6 max-w-6xl mx-auto">
      <!-- BPM控制 -->
      <div class="bg-dark/60 backdrop-blur-sm rounded-xl p-6 shadow-depth border border-slate-700">
        <h3 class="text-lg font-semibold mb-4 flex items-center">
          <i class="fa fa-tachometer text-accent mr-2"></i>
          BPM 控制
        </h3>
        <div class="space-y-4">
          <div class="flex items-center gap-4">
            <label for="bpmInput" class="text-slate-300 w-20">BPM 值:</label>
            <input 
              type="number" 
              id="bpmInput" 
              min="20" 
              max="120" 
              value="60" 
              class="flex-1 bg-slate-800 border border-slate-700 rounded-lg px-3 py-2 focus:outline-none focus:ring-2 focus:ring-primary"
            >
          </div>
          <input 
            type="range" 
            id="bpmSlider" 
            min="20" 
            max="120" 
            value="60" 
            class="w-full h-2 bg-slate-700 rounded-lg appearance-none cursor-pointer accent-primary"
          >
        </div>
      </div>
      
      <!-- 节拍循环设置 -->
      <div class="bg-dark/60 backdrop-blur-sm rounded-xl p-6 shadow-depth border border-slate-700">
        <h3 class="text-lg font-semibold mb-4 flex items-center">
          <i class="fa fa-retweet text-accent mr-2"></i>
          节拍循环
        </h3>
        <div class="space-y-4">
          <div class="flex items-center gap-4">
            <label for="beatsPerLoopInput" class="text-slate-300 w-24">每循环拍数:</label>
            <input 
              type="number" 
              id="beatsPerLoopInput" 
              min="1" 
              max="16" 
              value="4" 
              class="flex-1 bg-slate-800 border border-slate-700 rounded-lg px-3 py-2 focus:outline-none focus:ring-2 focus:ring-primary"
            >
          </div>
          <input 
            type="range" 
            id="beatsPerLoopSlider" 
            min="1" 
            max="16" 
            value="4" 
            class="w-full h-2 bg-slate-700 rounded-lg appearance-none cursor-pointer accent-primary"
          >
        </div>
      </div>
    </div>
    
    <!-- MIDI状态 -->
    <div class="mt-6 max-w-6xl mx-auto bg-dark/60 backdrop-blur-sm rounded-xl p-4 shadow-depth border border-slate-700">
      <div class="flex items-center justify-between">
        <div class="flex items-center gap-2">
          <i id="midiStatusIcon" class="fa fa-plug text-slate-500"></i>
          <span id="midiStatusText" class="text-slate-400">未检测MIDI设备</span>
        </div>
      </div>
    </div>
  </main>

  <!-- 胜利提示弹窗 -->
  <div id="successModal" class="fixed inset-0 bg-black/70 backdrop-blur-sm flex items-center justify-center z-50 hidden">
    <div class="bg-dark rounded-xl p-6 max-w-md w-full mx-4 border border-secondary/30 shadow-depth">
      <div class="text-center mb-4">
        <div class="inline-block p-3 bg-secondary/20 rounded-full mb-2">
          <i class="fa fa-trophy text-secondary text-2xl"></i>
        </div>
        <h3 class="text-xl font-bold text-secondary">恭喜胜利！</h3>
      </div>
      <div class="text-slate-300 text-center mb-4">
        <p class="mb-2">您已达到 <span id="modalTargetScore">100</span> 分目标，完成练习！</p>
        <p class="text-3xl font-bold text-primary mb-1">最终得分: <span id="finalScore">0</span></p>
        <p class="text-sm mb-1">最佳单次得分: <span id="finalBestScore">0</span></p>
        <p class="text-sm mb-1">按键次数: <span id="totalKeyPresses">0</span>次</p>
        <p class="text-sm text-slate-400" id="successDetails"></p>
      </div>
      <div class="flex justify-center">
        <button id="restartBtn" class="bg-primary hover:bg-primary/80 text-white font-medium py-2 px-6 rounded-lg transition-all-300">
          重新开始
        </button>
      </div>
    </div>
  </div>

  <footer class="bg-dark/80 backdrop-blur-md border-t border-slate-700 py-4 px-6 mt-8">
    <div class="container mx-auto text-center text-slate-400 text-sm">
      <p>节奏练习助手 &copy; 2023 - 提升您的节奏感</p>
    </div>
  </footer>

  <script>
    // 全局变量
    let audioContext = null;
    let isPlaying = false;
    let isInPreparation = false;
    let currentUser = ''; // 当前选中的用户
    let bpm = 60;
    let beatsPerLoop = 4;
    let timelineScale = 2.5; // 初始缩放50%
    let zoomLevel = 50; // 缩放百分比
    let targetScore = 100; // 目标分数（可自定义）
    let midiDelay = 0; // MIDI延时调整（ms）
    let midiAccess = null;
    let isMidiConnected = false;
    let displayUnit = 'ms';
    
    // 分数规则设置（7个预留范围）
    // 根据需求调整默认规则：0-100ms和101-200ms都是加5分
    let scoreRules = [
      { min: 0, max: 100, score: 5 },
      { min: 101, max: 200, score: 5 },
      { min: 201, max: 300, score: -5 },
      { min: 301, max: 400, score: -10 },
      { min: 401, max: 500, score: -15 },
      { min: 501, max: 600, score: -20 },
      { min: 601, max: 1000, score: -25 }
    ];
    
    let intervalId = null;
    let preparationIntervalId = null;
    let currentBeat = 0;
    let currentLoop = 0;
    let totalScore = 0; // 总分（从0开始）
    let individualScores = []; // 每次按键的得分
    let beatInterval = 60000 / bpm; // 节拍间隔（ms）
    let timelineScrollAnimationId = null;
    let practiceStartTime = 0; // 练习开始时间戳
    
    // 预设用户名单
    const presetUsers = [
      '杨沐恩',
      '王子锐',
      '高洋洋',
      '郭迦勒',
      '瓮迦勒',
      '刘亦康',
      '霍志蒙',
      '自定义'
    ];
    
    // 存储节拍、按键数据
    let beatTimes = []; // { time: 时间戳(ms), beatNumber: 节拍数, loopNumber: 循环数, isPreparation: 是否预备节拍 }
    let keyTimes = []; // { time: 时间戳(ms), targetBeat: 所属节拍索引, difference: 时间差(ms), score: 本次得分, total: 累计总分 }
    let pendingKeys = []; // 缓存等待下一节拍的按键
    
    // DOM元素引用
    const elements = {
      // 用户选择相关
      userSelectionModal: document.getElementById('userSelectionModal'),
      userList: document.getElementById('userList'),
      customUserName: document.getElementById('customUserName'),
      confirmUserBtn: document.getElementById('confirmUserBtn'),
      currentUserDisplay: document.getElementById('currentUserDisplay'),
      userNameText: document.getElementById('userNameText'),
      
      // 设置菜单相关
      settingsModal: document.getElementById('settingsModal'),
      settingsBtn: document.getElementById('settingsBtn'),
      targetScoreInput: document.getElementById('targetScoreInput'),
      targetScoreSlider: document.getElementById('targetScoreSlider'),
      midiDelayInput: document.getElementById('midiDelayInput'),
      midiDelaySlider: document.getElementById('midiDelaySlider'),
      saveSettingsBtn: document.getElementById('saveSettingsBtn'),
      cancelSettingsBtn: document.getElementById('cancelSettingsBtn'),
      resetRulesBtn: document.getElementById('resetRulesBtn'),
      scoreRulesContainer: document.getElementById('scoreRulesContainer'),
      targetScoreDisplay: document.getElementById('targetScoreDisplay'),
      targetScoreValue: document.getElementById('targetScoreValue'),
      ruleTargetScore: document.getElementById('ruleTargetScore'),
      modalTargetScore: document.getElementById('modalTargetScore'),
      currentRulesDisplay: document.getElementById('currentRulesDisplay'),
      
      // 控制按钮
      startStopBtn: document.getElementById('startStopBtn'),
      connectMidiBtn: document.getElementById('connectMidiBtn'),
      midiBtnText: document.getElementById('midiBtnText'),
      restartBtn: document.getElementById('restartBtn'),
      clearHistoryBtn: document.getElementById('clearHistoryBtn'),
      helpBtn: document.getElementById('helpBtn'),
      
      // 显示元素
      currentScoreDisplay: document.getElementById('currentScoreDisplay'),
      bestScoreDisplay: document.getElementById('bestScoreDisplay'),
      worstScoreDisplay: document.getElementById('worstScoreDisplay'),
      latestDifferenceDisplay: document.getElementById('latestDifferenceDisplay'),
      beatCounter: document.getElementById('beatCounter'),
      beatIndicator: document.getElementById('beatIndicator'),
      midiStatusIcon: document.getElementById('midiStatusIcon'),
      midiStatusText: document.getElementById('midiStatusText'),
      zoomLevelText: document.getElementById('zoomLevelText'),
      countdownOverlay: document.getElementById('countdownOverlay'),
      
      // 弹窗
      successModal: document.getElementById('successModal'),
      finalScore: document.getElementById('finalScore'),
      finalBestScore: document.getElementById('finalBestScore'),
      totalKeyPresses: document.getElementById('totalKeyPresses'),
      successDetails: document.getElementById('successDetails'),
      
      // 时间轴元素
      timelineContainer: document.getElementById('timelineContainer'),
      timeline: document.getElementById('timeline'),
      beatMarkers: document.getElementById('beatMarkers'),
      keyMarkers: document.getElementById('keyMarkers'),
      differenceLabels: document.getElementById('differenceLabels'),
      currentTimeIndicator: document.getElementById('currentTimeIndicator'),
      msUnitBtn: document.getElementById('msUnitBtn'),
      beatUnitBtn: document.getElementById('beatUnitBtn'),
      zoomInBtn: document.getElementById('zoomInBtn'),
      zoomOutBtn: document.getElementById('zoomOutBtn'),
      
      // 历史记录
      historyTableBody: document.getElementById('historyTableBody'),
      
      // 输入控件
      bpmInput: document.getElementById('bpmInput'),
      bpmSlider: document.getElementById('bpmSlider'),
      beatsPerLoopInput: document.getElementById('beatsPerLoopInput'),
      beatsPerLoopSlider: document.getElementById('beatsPerLoopSlider'),
    };
    
    // 音色配置
    const soundPresets = {
      click: { type: 'sine', frequency: 880, attack: 0.01, decay: 0.1, gain: 0.2 },
      preparation: { type: 'sine', frequency: 550, attack: 0.01, decay: 0.1, gain: 0.2 },
      'snare1': { type: 'square', frequency: 200, attack: 0.005, decay: 0.2, gain: 0.5, noise: true }
    };
    
    // 初始化音频上下文
    function initAudioContext() {
      if (!audioContext) {
        try {
          audioContext = new (window.AudioContext || window.webkitAudioContext)();
        } catch (e) {
          console.error('音频初始化失败:', e);
          alert('无法初始化音频，请检查浏览器设置');
        }
      }
      return audioContext;
    }
    
    // 播放声音
    function playSound(presetKey) {
      const ctx = initAudioContext();
      if (!ctx) return;
      
      const now = ctx.currentTime;
      const preset = soundPresets[presetKey];
      if (!preset) return;
      
      let source;
      if (preset.noise) {
        // 创建噪声源
        const bufferSize = 4096;
        const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
        source = ctx.createBufferSource();
        source.buffer = buffer;
      } else {
        source = ctx.createOscillator();
        source.type = preset.type;
        source.frequency.setValueAtTime(preset.frequency, now);
      }
      
      const gainNode = ctx.createGain();
      gainNode.gain.setValueAtTime(0, now);
      gainNode.gain.linearRampToValueAtTime(preset.gain, now + preset.attack);
      gainNode.gain.linearRampToValueAtTime(0, now + preset.attack + preset.decay);
      
      source.connect(gainNode);
      gainNode.connect(ctx.destination);
      source.start(now);
      source.stop(now + preset.attack + preset.decay + 0.1);
    }
    
    // 播放不同阶段的声音
    function playMetronomeSound() { playSound('click'); }
    function playPreparationSound() { playSound('preparation'); }
    function playKeySound() { playSound('snare1'); }
    function playSuccessSound() { 
      playSound('click');
      setTimeout(() => playSound('click'), 200);
    }
    
    // 格式化时间戳（用于记录显示）
    function formatTimestamp(timestamp) {
      const date = new Date(timestamp);
      return `${date.getHours().toString().padStart(2, '0')}:${date.getMinutes().toString().padStart(2, '0')}:${date.getSeconds().toString().padStart(2, '0')}.${Math.floor(date.getMilliseconds()/10).toString().padStart(2, '0')}`;
    }
    
    // 格式化日期（用于文件名）
    function formatDateForFilename(date) {
      return `${date.getFullYear()}${(date.getMonth()+1).toString().padStart(2, '0')}${date.getDate().toString().padStart(2, '0')}_${date.getHours().toString().padStart(2, '0')}${date.getMinutes().toString().padStart(2, '0')}${date.getSeconds().toString().padStart(2, '0')}`;
    }
    
    // 初始化分数规则设置界面
    function initScoreRulesUI() {
      elements.scoreRulesContainer.innerHTML = '';
      
      scoreRules.forEach((rule, index) => {
        const ruleGroup = document.createElement('div');
        ruleGroup.className = 'rule-group p-4';
        ruleGroup.innerHTML = `
          <div class="flex items-center gap-2 mb-3">
            <div class="rule-handle text-slate-500">
              <i class="fa fa-bars"></i>
            </div>
            <div class="text-sm font-medium ${index === 0 ? 'text-accent' : 'text-slate-300'}">
              范围 ${index + 1} ${index === 0 ? '(起始范围，最小值固定为0)' : ''}
            </div>
          </div>
          <div class="grid grid-cols-3 gap-3">
            <div>
              <label class="block text-xs text-slate-400 mb-1">最小值 (ms)</label>
              <input 
                type="number" 
                class="rule-min w-full bg-slate-800 border border-slate-700 rounded-lg px-2 py-1 text-sm focus:outline-none focus:ring-1 focus:ring-primary"
                value="${rule.min}"
                ${index === 0 ? 'readonly' : ''}
                data-index="${index}"
              >
            </div>
            <div>
              <label class="block text-xs text-slate-400 mb-1">最大值 (ms)</label>
              <input 
                type="number" 
                class="rule-max w-full bg-slate-800 border border-slate-700 rounded-lg px-2 py-1 text-sm focus:outline-none focus:ring-1 focus:ring-primary"
                value="${rule.max}"
                data-index="${index}"
              >
            </div>
            <div>
              <label class="block text-xs text-slate-400 mb-1">得分</label>
              <input 
                type="number" 
                class="rule-score w-full bg-slate-800 border border-slate-700 rounded-lg px-2 py-1 text-sm focus:outline-none focus:ring-1 focus:ring-primary"
                value="${rule.score}"
                data-index="${index}"
              >
            </div>
          </div>
        `;
        elements.scoreRulesContainer.appendChild(ruleGroup);
      });
      
      // 添加事件监听器
      document.querySelectorAll('.rule-max').forEach(input => {
        input.addEventListener('change', handleRuleMaxChange);
      });
      
      document.querySelectorAll('.rule-score').forEach(input => {
        input.addEventListener('change', handleRuleScoreChange);
      });
      
      // 除了第一个范围，添加最小值变化的监听器
      document.querySelectorAll('.rule-min:not([readonly])').forEach(input => {
        input.addEventListener('change', handleRuleMinChange);
      });
      
      updateCurrentRulesDisplay();
    }
    
    // 处理最大值变化
    function handleRuleMaxChange(e) {
      const index = parseInt(e.target.dataset.index);
      const newValue = parseInt(e.target.value) || 0;
      
      if (index < 0 || index >= scoreRules.length) return;
      
      // 确保最大值大于最小值
      if (newValue <= scoreRules[index].min) {
        e.target.value = scoreRules[index].min + 1;
        return;
      }
      
      scoreRules[index].max = newValue;
      
      // 更新下一个范围的最小值（如果存在）
      if (index < scoreRules.length - 1) {
        scoreRules[index + 1].min = newValue + 1;
        document.querySelector(`.rule-min[data-index="${index + 1}"]`).value = newValue + 1;
      }
    }
    
    // 处理最小值变化（仅非第一个范围）
    function handleRuleMinChange(e) {
      const index = parseInt(e.target.dataset.index);
      const newValue = parseInt(e.target.value) || 0;
      
      if (index <= 0 || index >= scoreRules.length) return;
      
      // 确保最小值大于前一个范围的最大值
      const prevMax = scoreRules[index - 1].max;
      if (newValue <= prevMax) {
        e.target.value = prevMax + 1;
        return;
      }
      
      scoreRules[index].min = newValue;
      
      // 更新前一个范围的最大值
      scoreRules[index - 1].max = newValue - 1;
      document.querySelector(`.rule-max[data-index="${index - 1}"]`).value = newValue - 1;
    }
    
    // 处理分数变化
    function handleRuleScoreChange(e) {
      const index = parseInt(e.target.dataset.index);
      const newValue = parseInt(e.target.value) || 0;
      
      if (index < 0 || index >= scoreRules.length) return;
      
      scoreRules[index].score = newValue;
    }
    
    // 更新当前规则显示
    function updateCurrentRulesDisplay() {
      elements.currentRulesDisplay.innerHTML = '';
      
      // 过滤掉未使用的规则（分数为0且不是最后一个）
      const usedRules = scoreRules.filter((rule, index) => 
        rule.score !== 0 || index === scoreRules.length - 1
      );
      
      usedRules.forEach((rule, displayIndex) => {
        const ruleElement = document.createElement('div');
        const scoreClass = rule.score >= 0 ? 'text-success' : 'text-danger';
        const scoreSign = rule.score >= 0 ? '+' : '';
        
        // 最后一个规则特殊处理
        const isLastRule = displayIndex === usedRules.length - 1;
        
        ruleElement.className = "flex items-center";
        ruleElement.innerHTML = `
          <span class="text-slate-300 mr-2">
            ±${rule.min}${isLastRule ? 'ms以上' : `-${rule.max}ms`}
          </span>：
          <span class="${scoreClass}">${scoreSign}${rule.score}分</span>
        `;
        
        elements.currentRulesDisplay.appendChild(ruleElement);
      });
    }
    
    // 恢复默认规则（0-100ms和101-200ms都是加5分）
    function resetToDefaultRules() {
      scoreRules = [
        { min: 0, max: 100, score: 5 },
        { min: 101, max: 200, score: 5 },
        { min: 201, max: 300, score: -5 },
        { min: 301, max: 400, score: -10 },
        { min: 401, max: 500, score: -15 },
        { min: 501, max: 600, score: -20 },
        { min: 601, max: 1000, score: -25 }
      ];
      
      initScoreRulesUI();
    }
    
    // 根据自定义规则计算得分
    function calculateScore(difference) {
      const absDiff = Math.abs(difference);
      
      // 查找匹配的规则范围
      for (let i = 0; i < scoreRules.length; i++) {
        const rule = scoreRules[i];
        // 最后一个规则处理所有更大的值
        if (i === scoreRules.length - 1) {
          return rule.score;
        }
        if (absDiff >= rule.min && absDiff <= rule.max) {
          return rule.score;
        }
      }
      
      // 默认返回0分（不应该到达这里）
      return 0;
    }
    
    // 更新分数显示
    function updateScoreDisplay() {
      // 当前总分
      elements.currentScoreDisplay.textContent = totalScore;
      
      // 最近差值
      const latestDiff = keyTimes.length > 0 ? keyTimes[keyTimes.length - 1].difference : 0;
      elements.latestDifferenceDisplay.textContent = latestDiff >= 0 ? `+${latestDiff}` : latestDiff;
      elements.latestDifferenceDisplay.className = `text-4xl md:text-5xl font-bold ${latestDiff >= 0 ? 'text-danger' : 'text-success'}`;
      
      // 最佳和最差单次得分
      if (individualScores.length === 0) {
        elements.bestScoreDisplay.textContent = "0";
        elements.worstScoreDisplay.textContent = "0";
        return;
      }
      
      const best = Math.max(...individualScores);
      const worst = Math.min(...individualScores);
      elements.bestScoreDisplay.textContent = best >= 0 ? `+${best}` : best;
      elements.worstScoreDisplay.textContent = worst >= 0 ? `+${worst}` : worst;
      
      // 检查是否达到胜利条件（使用自定义的目标分数）
      if (totalScore >= targetScore) {
        completeExercise('success');
      }
    }
    
    // 更新分数与差值记录表格
    function updateHistoryTable() {
      if (keyTimes.length === 0) {
        elements.historyTableBody.innerHTML = '<tr><td colspan="6" class="py-4 text-center text-slate-400">暂无记录</td></tr>';
        return;
      }
      
      elements.historyTableBody.innerHTML = '';
      // 反转数组，让最新的记录在最上面
      const reversedKeys = [...keyTimes].reverse();
      
      reversedKeys.forEach((key, index) => {
        const beat = beatTimes[key.targetBeat];
        // 用不同颜色显示正负差值和得分
        const diffClass = key.difference >= 0 ? 'text-danger' : 'text-success';
        const diffSign = key.difference >= 0 ? '+' : '';
        const scoreClass = key.score >= 0 ? 'text-success' : 'text-danger';
        const scoreSign = key.score >= 0 ? '+' : '';
        const originalIndex = keyTimes.length - index;
        // 为最新记录添加左侧高亮边框
        const rowClass = index === 0 ? 'history-row-latest' : '';
        // 达到目标分数时高亮显示
        const totalClass = key.total >= targetScore ? 'text-accent font-bold' : key.total >= 0 ? 'text-primary' : 'text-danger';
        
        const row = document.createElement('tr');
        row.className = `${rowClass} ${index % 2 === 0 ? 'border-b border-slate-800' : 'border-b border-slate-700 bg-slate-800/30'}`;
        row.innerHTML = `
          <td class="py-2 px-4">${originalIndex}</td>
          <td class="py-2 px-4">${beat.beatNumber} (循环 ${beat.loopNumber})</td>
          <td class="py-2 px-4">${formatTimestamp(key.time)}</td>
          <td class="py-2 px-4 ${diffClass}">${diffSign}${key.difference}</td>
          <td class="py-2 px-4 ${scoreClass}">${scoreSign}${key.score}</td>
          <td class="py-2 px-4 ${totalClass}">${key.total}</td>
        `;
        elements.historyTableBody.appendChild(row);
      });
    }
    
    // 清空历史记录
    function clearHistory() {
      keyTimes = [];
      pendingKeys = [];
      individualScores = [];
      totalScore = 0;
      updateHistoryTable();
      updateScoreDisplay();
      updateTimeline();
    }
    
    // 初始化用户选择对话框
    function initUserSelection() {
      elements.userList.innerHTML = '';
      
      presetUsers.forEach((user, index) => {
        const userOption = document.createElement('div');
        userOption.className = 'flex items-center';
        userOption.innerHTML = `
          <input type="radio" id="user_${index}" name="userSelection" value="${user}" class="mr-3 text-primary focus:ring-primary" ${index === 0 ? 'checked' : ''}>
          <label for="user_${index}" class="cursor-pointer">${user}</label>
        `;
        elements.userList.appendChild(userOption);
        
        // 为"自定义"选项添加事件监听
        if (user === '自定义') {
          const radioInput = document.getElementById(`user_${index}`);
          radioInput.addEventListener('change', (e) => {
            elements.customUserName.disabled = !e.target.checked;
            if (e.target.checked) {
              elements.customUserName.focus();
            }
          });
        }
      });
    }
    
    // 处理用户选择确认
    function confirmUserSelection() {
      const selectedRadio = document.querySelector('input[name="userSelection"]:checked');
      if (!selectedRadio) return;
      
      let userName = selectedRadio.value;
      
      // 如果选择了自定义，使用输入框的值
      if (userName === '自定义') {
        userName = elements.customUserName.value.trim() || '自定义用户';
      }
      
      currentUser = userName;
      elements.userNameText.textContent = currentUser;
      elements.currentUserDisplay.classList.remove('hidden');
      elements.currentUserDisplay.classList.add('flex');
      
      // 隐藏用户选择对话框
      elements.userSelectionModal.classList.remove('modal-visible');
      
      // 开始练习
      startMetronome();
    }
    
    // 保存设置
    function saveSettings() {
      // 保存目标分数
      const newTargetScore = parseInt(elements.targetScoreInput.value);
      if (newTargetScore >= 10 && newTargetScore <= 5000) {
        targetScore = newTargetScore;
        // 更新界面显示
        elements.targetScoreValue.textContent = targetScore;
        elements.ruleTargetScore.textContent = targetScore;
        elements.modalTargetScore.textContent = targetScore;
      }
      
      // 保存MIDI延时设置
      const newMidiDelay = parseInt(elements.midiDelayInput.value);
      if (newMidiDelay >= -100 && newMidiDelay <= 100) {
        midiDelay = newMidiDelay;
      }
      
      // 更新滑块值
      elements.targetScoreSlider.value = targetScore;
      elements.midiDelaySlider.value = midiDelay;
      
      // 更新当前规则显示
      updateCurrentRulesDisplay();
      
      // 如果正在练习，更新表格中已达标的行
      if (isPlaying) {
        updateHistoryTable();
      }
      
      // 隐藏设置对话框
      elements.settingsModal.classList.remove('modal-visible');
    }
    
    // 导出记录为TXT文件
    function exportRecordsToTxt() {
      if (keyTimes.length === 0) {
        alert('没有记录可导出');
        return;
      }
      
      // 获取练习结束时间
      const endTime = new Date();
      
      // 计算统计数据
      const totalCount = keyTimes.length;
      const bestScore = individualScores.length ? Math.max(...individualScores) : 0;
      const worstScore = individualScores.length ? Math.min(...individualScores) : 0;
      const totalDifference = keyTimes.reduce((sum, item) => sum + Math.abs(item.difference), 0);
      const averageDifference = Math.round(totalDifference / totalCount);
      
      // 构建TXT内容
      let txtContent = `节奏练习记录 - ${currentUser}\n`;
      txtContent += `练习时间: ${formatTimestamp(practiceStartTime)} 至 ${formatTimestamp(endTime.getTime())}\n`;
      txtContent += `BPM: ${bpm} | 每循环拍数: ${beatsPerLoop} | 目标分数: ${targetScore}\n`;
      txtContent += `MIDI延时调整: ${midiDelay}ms\n`;
      txtContent += `总按键次数: ${totalCount} | 最终得分: ${totalScore}\n`;
      txtContent += `最佳单次得分: ${bestScore >= 0 ? '+' : ''}${bestScore} | 最差单次得分: ${worstScore >= 0 ? '+' : ''}${worstScore}\n`;
      txtContent += `平均时间差: ${averageDifference}ms\n\n`;
      
      txtContent += "计分规则:\n";
      scoreRules.forEach((rule, index) => {
        if (rule.score !== 0 || index === scoreRules.length - 1) {
          const isLastRule = index === scoreRules.length - 1;
          txtContent += `±${rule.min}${isLastRule ? 'ms以上' : `-${rule.max}ms`}: ${rule.score >= 0 ? '+' : ''}${rule.score}分\n`;
        }
      });
      
      txtContent += "\n详细记录:\n";
      txtContent += "序号\t所属节拍\t按键时间\t时间差(ms)\t本次得分\t累计总分\n";
      
      keyTimes.forEach((key, index) => {
        const beat = beatTimes[key.targetBeat];
        const diffSign = key.difference >= 0 ? '+' : '';
        const scoreSign = key.score >= 0 ? '+' : '';
        txtContent += `${index+1}\t${beat.beatNumber}(循环${beat.loopNumber})\t${formatTimestamp(key.time)}\t${diffSign}${key.difference}\t${scoreSign}${key.score}\t${key.total}\n`;
      });
      
      // 创建并下载文件
      const blob = new Blob([txtContent], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `节奏练习记录_${currentUser}_${formatDateForFilename(endTime)}.txt`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }
    
    // 处理预备节拍（4→3→2→1）
    function handlePreparationBeat(count) {
      // 显示倒计时数字
      elements.countdownOverlay.textContent = count;
      elements.countdownOverlay.classList.add('countdown-visible');
      setTimeout(() => elements.countdownOverlay.classList.remove('countdown-visible'), beatInterval * 0.7);
      
      // 视觉反馈
      elements.beatIndicator.classList.add('beat-animation');
      setTimeout(() => elements.beatIndicator.classList.remove('beat-animation'), 300);
      
      // 记录预备节拍时间
      playPreparationSound();
      beatTimes.push({
        time: Date.now(),
        beatNumber: count,
        loopNumber: 0,
        isPreparation: true
      });
      
      updateTimeline();
    }
    
    // 预备阶段逻辑
    function startPreparation() {
      isInPreparation = true;
      let currentCount = beatsPerLoop; // 从4开始
      
      const firstPreparationTime = Date.now();
      handlePreparationBeat(currentCount);
      
      preparationIntervalId = setInterval(() => {
        currentCount--;
        if (currentCount >= 1) {
          handlePreparationBeat(currentCount);
        } else {
          // 计算最后一个预备节拍到正式节拍1的精确时间
          const lastPreparationTime = beatTimes[beatTimes.length - 1].time;
          const timeToNextBeat = beatInterval - (Date.now() - lastPreparationTime);
          
          clearInterval(preparationIntervalId);
          
          // 精确触发正式节拍1
          setTimeout(() => {
            isInPreparation = false;
            startFormalPractice();
          }, Math.max(0, timeToNextBeat));
        }
      }, beatInterval);
    }
    
    // 正式开始练习
    function startFormalPractice() {
      // 记录练习开始时间
      practiceStartTime = Date.now();
      
      // 重置状态
      currentBeat = 0;
      currentLoop = 0;
      totalScore = 0;
      individualScores = [];
      keyTimes = [];
      pendingKeys = [];
      
      updateScoreDisplay();
      // 显示目标分数
      elements.targetScoreDisplay.classList.remove('hidden');
      elements.targetScoreDisplay.classList.add('flex');
      
      // 立即处理第一个正式节拍（1）
      handleFormalBeat();
      intervalId = setInterval(handleFormalBeat, beatInterval);
      
      elements.currentTimeIndicator.classList.remove('hidden');
    }
    
    // 处理正式节拍
    function handleFormalBeat() {
      currentBeat = (currentBeat % beatsPerLoop) + 1;
      elements.beatCounter.textContent = currentBeat;
      
      // 视觉反馈
      elements.beatIndicator.classList.add('beat-animation');
      setTimeout(() => elements.beatIndicator.classList.remove('beat-animation'), 300);
      
      // 记录正式节拍时间
      const currentTime = Date.now();
      const newBeat = {
        time: currentTime,
        beatNumber: currentBeat,
        loopNumber: currentLoop + (currentBeat === 1 ? 1 : 0),
        isPreparation: false
      };
      beatTimes.push(newBeat);
      playMetronomeSound();
      
      // 处理缓存的按键
      processPendingKeys(newBeat, beatTimes.length - 1);
      
      // 更新时间轴
      updateTimeline();
      
      // 更新循环计数
      if (currentBeat === beatsPerLoop) {
        currentLoop++;
      }
    }
    
    // 处理缓存的按键（应用计分规则）
    function processPendingKeys(newBeat, newBeatIndex) {
      if (pendingKeys.length === 0) return;
      
      const halfInterval = beatInterval / 2;
      pendingKeys.forEach(pendingKey => {
        // 计算与新节拍的时间差，应用MIDI延时调整
        let difference = pendingKey.time - newBeat.time;
        // 如果是MIDI输入，应用延时调整
        if (pendingKey.isMidi) {
          difference -= midiDelay;
        }
        
        const clampedDiff = Math.max(-halfInterval, difference);
        
        // 应用计分规则计算得分
        const score = calculateScore(clampedDiff);
        
        // 更新总分
        totalScore += score;
        
        // 记录数据（包含本次得分和累计总分）
        keyTimes.push({ 
          time: pendingKey.time, 
          targetBeat: newBeatIndex, 
          difference: Math.round(clampedDiff), 
          score,
          total: totalScore
        });
        individualScores.push(score);
      });
      
      // 清空缓存
      pendingKeys = [];
      
      // 更新显示
      updateScoreDisplay();
      updateTimeline();
      updateHistoryTable(); // 每次有新记录都更新表格
    }
    
    // 更新当前时间指示器
    function updateCurrentTimeIndicator() {
      if (beatTimes.length === 0) return;
      const currentTime = Date.now();
      const earliestTime = beatTimes[0].time;
      const position = (currentTime - earliestTime) * timelineScale;
      elements.currentTimeIndicator.style.left = `${position}px`;
      
      // 持续滚动时间轴
      if (isPlaying && !isInPreparation && beatTimes.length > 0) {
        smoothScrollTimelineContinuously();
      }
    }
    
    // 时间轴滚动控制
    function smoothScrollTimelineContinuously() {
      const currentTime = Date.now();
      const earliestTime = beatTimes[0].time;
      const targetPos = (currentTime - earliestTime) * timelineScale - elements.timelineContainer.offsetWidth * 0.8;
      
      if (Math.abs(elements.timelineContainer.scrollLeft - targetPos) > 2) {
        smoothScrollTimelineToCurrent(targetPos);
      }
    }
    
    function smoothScrollTimelineToCurrent(targetPos) {
      if (timelineScrollAnimationId) cancelAnimationFrame(timelineScrollAnimationId);
      
      const startPos = elements.timelineContainer.scrollLeft;
      const distance = targetPos - startPos;
      const duration = 1000;
      let startTime = null;
      
      function animation(currentTime) {
        if (!startTime) startTime = currentTime;
        const elapsed = currentTime - startTime;
        const progress = Math.min(elapsed / duration, 1);
        const easeProgress = 1 - Math.pow(1 - progress, 3);
        
        elements.timelineContainer.scrollLeft = startPos + distance * easeProgress;
        
        if (progress < 1) {
          timelineScrollAnimationId = requestAnimationFrame(animation);
        } else {
          timelineScrollAnimationId = null;
        }
      }
      
      timelineScrollAnimationId = requestAnimationFrame(animation);
    }
    
    // 缩放控制
    function adjustZoom(change) {
      const newZoom = Math.max(10, Math.min(300, zoomLevel + change));
      if (newZoom !== zoomLevel) {
        zoomLevel = newZoom;
        timelineScale = 5 * (zoomLevel / 100);
        elements.zoomLevelText.textContent = `${zoomLevel}%`;
        updateTimeline();
        updateCurrentTimeIndicator();
      }
    }
    
    // 更新时间轴
    function updateTimeline() {
      elements.beatMarkers.innerHTML = '';
      elements.keyMarkers.innerHTML = '';
      elements.differenceLabels.innerHTML = '';
      
      if (beatTimes.length === 0) return;
      const earliestTime = beatTimes[0].time;
      
      // 绘制所有节拍标记
      beatTimes.forEach((beat, index) => {
        const position = (beat.time - earliestTime) * timelineScale;
        
        // 节拍线
        const marker = document.createElement('div');
        marker.className = `timeline-marker ${beat.isPreparation ? 'bg-accent/60' : 'bg-primary'} h-1/2 top-1/4`;
        marker.style.left = `${position}px`;
        elements.beatMarkers.appendChild(marker);
        
        // 节拍标签
        const label = document.createElement('div');
        label.className = `timeline-label ${beat.isPreparation ? 'text-accent' : 'text-primary'} text-xs -top-6`;
        label.style.left = `${position}px`;
        label.textContent = beat.isPreparation ? `预备 ${beat.beatNumber}` : `拍 ${beat.beatNumber}`;
        elements.beatMarkers.appendChild(label);
      });
      
      // 绘制按键标记和差值
      keyTimes.forEach(key => {
        const position = (key.time - earliestTime) * timelineScale;
        
        // 按键标记
        const marker = document.createElement('div');
        marker.className = 'timeline-marker bg-secondary h-1/2 bottom-1/4';
        marker.style.left = `${position}px`;
        elements.keyMarkers.appendChild(marker);
        
        // 显示差值和分数
        const label = document.createElement('div');
        const diffClass = key.difference >= 0 ? 'text-danger' : 'text-success';
        const scoreClass = key.score >= 0 ? 'text-success' : 'text-danger';
        label.className = `timeline-label text-xs`;
        label.style.top = key.difference >= 0 ? '28px' : '8px';
        label.style.left = `${position}px`;
        label.innerHTML = `${key.difference >= 0 ? '+' : ''}${key.difference}ms <span class="${scoreClass}">(${key.score >= 0 ? '+' : ''}${key.score}分)</span>`;
        elements.differenceLabels.appendChild(label);
      });
      
      // 自动扩展时间轴宽度
      if (beatTimes.length > 0) {
        const lastBeatTime = beatTimes[beatTimes.length - 1].time;
        const lastPosition = (lastBeatTime - earliestTime) * timelineScale + 400;
        elements.timeline.style.width = `${Math.max(elements.timeline.offsetWidth, lastPosition)}px`;
      }
    }
    
    // 处理按键（记录并计算分数）- 鼠标按下时记录
    function handleKeyPress(isMidi = false) {
      if (!isPlaying) return;
      
      // 仅在预备阶段最后一个节拍（1）或正式阶段才记录按键
      if (isInPreparation && elements.countdownOverlay.textContent !== '1') {
        return;
      }
      
      playKeySound();
      const keyTime = Date.now();
      const halfInterval = beatInterval / 2;
      
      // 找到最近的非预备节拍
      let latestFormalBeatIndex = beatTimes.findLastIndex(beat => !beat.isPreparation);
      
      if (latestFormalBeatIndex !== -1) {
        const latestBeat = beatTimes[latestFormalBeatIndex];
        const timeSinceLatestBeat = keyTime - latestBeat.time;
        
        // 中间线左侧 → 归属当前节拍
        if (timeSinceLatestBeat <= halfInterval) {
          // 计算时间差，应用MIDI延时调整
          let difference = keyTime - latestBeat.time;
          if (isMidi) {
            difference -= midiDelay;
          }
          
          const score = calculateScore(difference);
          
          // 更新总分
          totalScore += score;
          
          // 记录当前按键的分数和差值
          keyTimes.push({ 
            time: keyTime, 
            targetBeat: latestFormalBeatIndex, 
            difference: Math.round(difference), 
            score,
            total: totalScore
          });
          individualScores.push(score);
          
          // 立即更新显示
          updateScoreDisplay();
          updateTimeline();
          updateHistoryTable();
        } else {
          pendingKeys.push({ time: keyTime, isMidi });
        }
      } else {
        // 预备1之后，正式1之前的按键
        pendingKeys.push({ time: keyTime, isMidi });
      }
    }
    
    // 完成练习
    function completeExercise(reason) {
      stopMetronome();
      elements.currentTimeIndicator.classList.add('hidden');
      
      const best = individualScores.length ? Math.max(...individualScores) : 0;
      const totalCount = keyTimes.length;
      
      elements.finalScore.textContent = totalScore;
      elements.finalBestScore.textContent = best >= 0 ? `+${best}` : best;
      elements.totalKeyPresses.textContent = totalCount;
      elements.modalTargetScore.textContent = targetScore;
      elements.successDetails.textContent = reason === 'success' 
        ? `恭喜达到${targetScore}分目标！共按键 ${totalCount} 次`
        : `已停止练习，共按键 ${totalCount} 次`;
      
      elements.successModal.classList.remove('hidden');
      playSuccessSound();
      
      // 导出记录
      exportRecordsToTxt();
    }
    
    // 节拍器控制
    function toggleMetronome() {
      if (isPlaying) {
        stopMetronome();
        // 停止时导出记录（如果有记录）
        if (keyTimes.length > 0) {
          completeExercise('stopped');
        }
      } else {
        // 开始前显示用户选择对话框
        elements.userSelectionModal.classList.add('modal-visible');
      }
    }
    
    function startMetronome() {
      if (!initAudioContext()) return;
      
      // 重置状态
      beatTimes = [];
      keyTimes = [];
      pendingKeys = [];
      currentBeat = 0;
      currentLoop = 0;
      totalScore = 0;
      individualScores = [];
      
      // 更新显示
      updateScoreDisplay();
      elements.timeline.style.width = '5000px';
      updateTimeline();
      updateHistoryTable();
      
      // 更新按钮样式
      elements.startStopBtn.innerHTML = '<i class="fa fa-stop"></i><span>停止练习</span>';
      elements.startStopBtn.classList.remove('bg-primary');
      elements.startStopBtn.classList.add('bg-danger');
      elements.beatIndicator.classList.add('border-primary');
      
      isPlaying = true;
      beatInterval = 60000 / bpm;
      
      // 启动定时更新当前时间指示器
      setInterval(updateCurrentTimeIndicator, 100);
      
      // 开始预备阶段
      startPreparation();
    }
    
    function stopMetronome() {
      if (intervalId) clearInterval(intervalId);
      if (preparationIntervalId) clearInterval(preparationIntervalId);
      if (timelineScrollAnimationId) cancelAnimationFrame(timelineScrollAnimationId);
      
      elements.currentTimeIndicator.classList.add('hidden');
      elements.countdownOverlay.classList.remove('countdown-visible');
      elements.targetScoreDisplay.classList.add('hidden');
      elements.targetScoreDisplay.classList.remove('flex');
      
      elements.startStopBtn.innerHTML = '<i class="fa fa-play"></i><span>开始练习</span>';
      elements.startStopBtn.classList.remove('bg-danger');
      elements.startStopBtn.classList.add('bg-primary');
      elements.beatIndicator.classList.remove('border-primary');
      
      isPlaying = false;
      isInPreparation = false;
    }
    
    // MIDI处理
    function handleMidiInput(message) {
      const [status, note, velocity] = message.data;
      // 当MIDI音符按下时触发（velocity > 0）
      if ((status & 0xF0) === 0x90 && velocity > 0) {
        // 标记为MIDI输入，以便应用延时调整
        handleKeyPress(true);
      }
    }
    
    // 连接MIDI设备
    async function connectMidi() {
      try {
        elements.midiStatusIcon.className = 'fa fa-spinner fa-spin text-accent';
        elements.midiStatusText.textContent = '正在检测MIDI设备...';
        elements.midiBtnText.textContent = '正在连接...';
        elements.connectMidiBtn.disabled = true;
        
        if (!midiAccess) {
          midiAccess = await navigator.requestMIDIAccess({ sysex: false });
        }
        
        // 监听设备连接状态变化
        midiAccess.onstatechange = handleMidiStateChange;
        
        // 连接所有可用输入设备
        const inputs = midiAccess.inputs.values();
        let hasInputs = false;
        for (let input of inputs) {
          hasInputs = true;
          input.onmidimessage = handleMidiInput;
        }
        
        updateMidiStatus(hasInputs);
      } catch (err) {
        console.error('MIDI连接错误:', err);
        elements.midiStatusIcon.className = 'fa fa-exclamation-triangle text-danger';
        elements.midiStatusText.textContent = 'MIDI连接失败';
        elements.midiBtnText.textContent = '重试连接';
      } finally {
        elements.connectMidiBtn.disabled = false;
      }
    }
    
    // 处理MIDI设备状态变化
    function handleMidiStateChange(event) {
      console.log('MIDI设备状态变化:', event.port.name, event.port.state);
      
      // 如果设备已连接且是输入设备，添加消息监听
      if (event.port.state === 'connected' && event.port.type === 'input') {
        event.port.onmidimessage = handleMidiInput;
        updateMidiStatus(true);
      } 
      // 如果设备已断开连接，检查是否还有其他设备
      else if (event.port.state === 'disconnected' && event.port.type === 'input') {
        const inputs = midiAccess.inputs.values();
        let hasConnectedInputs = false;
        for (let input of inputs) {
          if (input.state === 'connected') {
            hasConnectedInputs = true;
            break;
          }
        }
        updateMidiStatus(hasConnectedInputs);
      }
    }
    
    // 更新MIDI状态显示
    function updateMidiStatus(connected) {
      if (connected) {
        isMidiConnected = true;
        elements.midiStatusIcon.className = 'fa fa-plug text-secondary';
        elements.midiStatusText.textContent = 'MIDI设备已连接';
        elements.midiBtnText.textContent = '断开连接';
      } else {
        isMidiConnected = false;
        elements.midiStatusIcon.className = 'fa fa-plug text-slate-500';
        elements.midiStatusText.textContent = '未检测到MIDI设备';
        elements.midiBtnText.textContent = '连接MIDI设备';
      }
    }
    
    // 断开MIDI连接
    function disconnectMidi() {
      if (midiAccess) {
        // 移除所有输入设备的消息监听
        const inputs = midiAccess.inputs.values();
        for (let input of inputs) {
          input.onmidimessage = null;
        }
        updateMidiStatus(false);
      }
    }
    
    // 绑定事件
    function bindEvents() {
      // 用户选择事件
      elements.confirmUserBtn.addEventListener('click', confirmUserSelection);
      
      // 设置菜单事件
      elements.settingsBtn.addEventListener('click', () => {
        elements.settingsModal.classList.add('modal-visible');
        // 同步输入框和滑块的值
        elements.targetScoreInput.value = targetScore;
        elements.targetScoreSlider.value = targetScore;
        elements.midiDelayInput.value = midiDelay;
        elements.midiDelaySlider.value = midiDelay;
        initScoreRulesUI();
      });
      
      elements.saveSettingsBtn.addEventListener('click', saveSettings);
      elements.cancelSettingsBtn.addEventListener('click', () => {
        elements.settingsModal.classList.remove('modal-visible');
      });
      
      elements.resetRulesBtn.addEventListener('click', resetToDefaultRules);
      
      // 目标分数输入框和滑块同步
      elements.targetScoreInput.addEventListener('input', e => {
        const val = parseInt(e.target.value);
        if (val >= 10 && val <= 5000) {
          elements.targetScoreSlider.value = val;
        }
      });
      
      elements.targetScoreSlider.addEventListener('input', e => {
        elements.targetScoreInput.value = e.target.value;
      });
      
      // MIDI延时输入框和滑块同步
      elements.midiDelayInput.addEventListener('input', e => {
        const val = parseInt(e.target.value);
        if (val >= -100 && val <= 100) {
          elements.midiDelaySlider.value = val;
        }
      });
      
      elements.midiDelaySlider.addEventListener('input', e => {
        elements.midiDelayInput.value = e.target.value;
      });
      
      // BPM控制
      elements.bpmInput.addEventListener('input', e => {
        const val = parseInt(e.target.value);
        if (val >= 20 && val <= 120) {
          bpm = val;
          elements.bpmSlider.value = val;
          if (isPlaying && !isInPreparation) {
            clearInterval(intervalId);
            beatInterval = 60000 / bpm;
            intervalId = setInterval(handleFormalBeat, beatInterval);
          }
        }
      });
      
      elements.bpmSlider.addEventListener('input', e => {
        bpm = parseInt(e.target.value);
        elements.bpmInput.value = bpm;
        if (isPlaying && !isInPreparation) {
          clearInterval(intervalId);
          beatInterval = 60000 / bpm;
          intervalId = setInterval(handleFormalBeat, beatInterval);
        }
      });
      
      // 节拍循环设置
      elements.beatsPerLoopInput.addEventListener('input', e => {
        const val = parseInt(e.target.value);
        if (val >= 1 && val <= 16) {
          beatsPerLoop = val;
          elements.beatsPerLoopSlider.value = val;
        }
      });
      
      elements.beatsPerLoopSlider.addEventListener('input', e => {
        beatsPerLoop = parseInt(e.target.value);
        elements.beatsPerLoopInput.value = beatsPerLoop;
      });
      
      // 缩放控制
      elements.zoomInBtn.addEventListener('click', () => adjustZoom(1));
      elements.zoomOutBtn.addEventListener('click', () => adjustZoom(-1));
      
      // 控制按钮事件
      elements.startStopBtn.addEventListener('click', toggleMetronome);
      // 修改为鼠标按下时记录，而不是松开时
      elements.beatIndicator.addEventListener('mousedown', (e) => {
        e.preventDefault(); // 防止默认行为
        handleKeyPress();
      });
      elements.clearHistoryBtn.addEventListener('click', clearHistory);
      elements.restartBtn.addEventListener('click', () => {
        elements.successModal.classList.add('hidden');
        // 重新开始时显示用户选择对话框
        elements.userSelectionModal.classList.add('modal-visible');
      });
      
      // MIDI事件
      elements.connectMidiBtn.addEventListener('click', () => {
        if (isMidiConnected) {
          disconnectMidi();
        } else {
          connectMidi();
        }
      });
      
      // 初始化音频（用户交互触发）
      document.body.addEventListener('click', initAudioContext, { once: true });
    }
    
    // 初始化
    function init() {
      // 设置默认目标分数显示
      elements.targetScoreValue.textContent = targetScore;
      elements.ruleTargetScore.textContent = targetScore;
      elements.modalTargetScore.textContent = targetScore;
      
      // 设置默认MIDI延时
      elements.midiDelayInput.value = midiDelay;
      elements.midiDelaySlider.value = midiDelay;
      
      elements.zoomLevelText.textContent = `${zoomLevel}%`;
      updateMidiStatus(false);
      initUserSelection();
      updateCurrentRulesDisplay();
      bindEvents();
      
      // 页面加载时自动尝试连接MIDI设备
      connectMidi();
    }
    
    window.addEventListener('DOMContentLoaded', init);
  </script>
</body>
</html>
